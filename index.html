<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>
      Wake Lock API
    </title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async
    class='remove'></script>
    <script class='remove'>
      /*stops tidy screwing things up*/
      var respecConfig = {
        specStatus: "ED",
        shortName: "wake-lock",
        editors: [{
          name: "Kenneth Rohde Christiansen",
          company: "Intel Corporation",
          companyURL: "https://intel.com/",
          w3cid: 57705
        }],
        formerEditors: [{
          name: "Ilya Bogdanovich",
          url: "mailto:bogdanovichiy@yandex-team.ru",
          company: "Yandex",
          w3cid: "71741"
        }, {
          name: "Andrey Logvinov",
          url: "mailto:alogvinov@yandex-team.ru",
          company: "Yandex",
          w3cid: "75989"
        }, {
          name: "Marcos Caceres",
          url: "mailto:marcos@marcosc.com",
          company: "Mozilla",
          w3cid: "39125"
        }],
        github: "https://github.com/w3c/wake-lock/",
        wg: "Device APIs Working Group",
        wgURI: "https://www.w3.org/2009/dap/",
        wgPublicList: "public-device-apis",
        wgPatentURI: "https://www.w3.org/2004/01/pp-impl/43696/status",
        testSuiteURI: "https://w3c-test.org/wake-lock/",
        implementationReportURI: "https://www.w3.org/2009/dap/wiki/ImplementationStatus",
        otherLinks: [{
          key: 'Quality Assurance Lead',
          data: [{
            value: 'Wanming Lin (Intel)',
            href: 'https://github.com/Honry'
          }]
        }, {
          key: "Implementation status",
          data: [{
            value: "Blink",
            href: "https://bugs.chromium.org/p/chromium/issues/detail?id=257511"
          }]
        }],
        xref: "web-platform"
      };
    </script>
  </head>
  <body data-cite="FEATURE-POLICY PERMISSIONS">
    <section id='abstract'>
      <p>
        This document specifies an API that allows web applications to request
        a wake lock. A wake lock prevents some aspect of the device from
        entering a power-saving state (e.g., preventing the system from turning
        off the screen).
      </p>
    </section>
    <section id='sotd'>
      <p>
        Implementors need to be aware that this specification is extremely
        unstable. <strong>Implementors who are not taking part in the
        discussions will find the specification changing out from under them in
        incompatible ways.</strong> Vendors interested in implementing this
        specification before it eventually reaches the Candidate Recommendation
        phase should <a href=
        "https://github.com/w3c/wake-lock/issues">subscribe to the repository
        on GitHub</a> and take part in the discussions.
      </p>
    </section>
    <section>
      <h2>
        Introduction
      </h2>
      <p>
        Modern OSs achieve longer battery life by implementing aggressive power
        management, meaning that shortly after the lack of user activity, a
        host device may lower the screen brightness, turn the screen off and
        even let the CPU go into a deep power state, allowing to sip as little
        power as possible.
      </p>
      <p>
        Though this is great for prolonged battery life, it can sometime hinder
        good, valid use-cases such as:
      </p>
      <ul>
        <li>Use turn-by-turn navigation while walking and driving and not
        interacting with the phone.
        </li>
        <li>Allow an external device to read a boarding card with a barcode on
        a phone.
        </li>
        <li>Showing a presentation where each slide is shown for a prolonged
        period.
        </li>
        <li>Perform longer computations before the device goes into deep sleep
        mode, such as media processing.
        </li>
      </ul>
      <p>
        More use-cases can be found in <a href=
        "https://w3c-webmob.github.io/wake-lock-use-cases/">Use Cases and
        Requirements</a>.
      </p>
      <p>
        A wake lock will generally prevent something from happening, but UAs
        (and the underlying OS) may time limit a wake lock given the battery
        status (wall power connected, discharging, low battery level), or even
        disallow wake locks in the case a power saving mode is activated.
      </p>
      <p>
        Any active wake lock MUST also prevent the page from entering UA
        induced <a data-cite="page-lifecycle#lifecycle-frozen">CPU
        suspension</a> as defined by [[PAGE-LIFECYCLE]].
      </p>
      <p>
        This specification defines the following <dfn>wake lock types</dfn>:
      </p>
      <ol>
        <li>A <dfn>screen wake lock</dfn> prevents the screen from turning off.
        Only visible documents can acquire the wake lock.
        </li>
        <li>A <dfn>system wake lock</dfn> prevents the CPU from entering a deep
        power state. This may also prevent communication chips such as cellular
        or Wi-Fi from sleeping.
        </li>
      </ol>
      <div class="note">
        Though a <a>system wake lock</a> will usually keep the network
        connection alive, it is most likely not required for such. Audio
        streaming on devices usually does the same and if you need it for long
        running upload and download tasks, such as for a podcast, other more
        appropriate features exist, like [[BACKGROUND-FETCH]].
      </div>
      <div class="note">
        One type of wake lock can imply the effects of another: for example,
        screen wake lock logically implies that the program which displays
        information on the screen continues running, as if the system wake lock
        were also applied. But to avoid dependence on such implementation
        details which may not always be true, this specification treats all
        types of wake locks as independent.
      </div>
      <p>
        A <a>user agent</a> can <dfn data-lt="deny wake lock">deny a wake
        lock</dfn> of a particular <a>wake lock type</a> for a particular
        {{Document}} by any implementation-specific reason, for example, a user
        or platform setting or preference.
      </p>
    </section>
    <section data-cite="feature-policy">
      <h3>
        Policy control
      </h3>
      <p data-tests=
      "wakelock-enabled-on-self-origin-by-feature-policy.https.sub.html, wakelock-enabled-by-feature-policy-attribute-redirect-on-load.https.sub.html, wakelock-enabled-by-feature-policy-attribute.https.sub.html, wakelock-enabled-by-feature-policy.https.sub.html">
        The <dfn>wake lock feature</dfn> is a <a>policy-controlled feature</a>
        with <a data-cite="feature-policy#feature-name">feature name</a>
        `"wake-lock"` and <a>default allowlist</a> `["self"]`.
      </p>
      <div class="note">
        <p>
          The <a>default allowlist</a> of `["self"]` allows wake lock usage in
          same-origin nested frames but prevents third-party content from using
          wake locks.
        </p>
        <p>
          Third-party usage can be selectively enabled by adding
          `allow="wake-lock"` attribute to the frame container element:
        </p>
        <pre class="example html" title="Enabling wake-lock on remote content">
          &lt;iframe src="https://third-party.com" allow="wake-lock"/&gt;&lt;/iframe&gt;
        </pre>
        <p>
          Alternatively, the wake lock feature can be disabled completely by
          specifying the feature policy in a HTTP response header:
        </p>
        <pre class="example http" title="Feature Policy over HTTP">
          Feature-Policy: {"wake-lock": []}
        </pre>
        <p>
          See [[[FEATURE-POLICY]]] for more details.
        </p>
      </div>
    </section>
    <section>
      <h3>
        Permissions and user prompts
      </h3>
      <p>
        The [[PERMISSIONS]] API provides a uniform way for websites to request
        permissions from users and query which permissions they have.
      </p>
      <p>
        It is recommended that a UA shows some form of unobtrusive notification
        that informs the user when a wake lock is active, as well as provides
        the user with the means to <a href="#dfn-block-a-permission">block</a>
        the ongoing operation, or simply dismiss the notification.
      </p>
      <p>
        The `"wake-lock"` <a>powerful feature</a> is defined as follows:
      </p>
      <p data-dfn-for="WakeLockPermissionDescriptor">
        The <a>permission descriptor type</a> is represented by the
        <dfn>WakeLockPermissionDescriptor</dfn> <a>dictionary</a>, which
        augments the {{PermissionDescriptor}} with a <dfn>type</dfn> member,
        allowing for more fine-grained permissions.
      </p>
      <pre class="idl">
        dictionary WakeLockPermissionDescriptor : PermissionDescriptor {
          WakeLockType type;
        };
      </pre>
      <p>
        The {{PermissionDescriptor.name}} is `"wake-lock"`
      </p>
      <p>
        Within this section, |descriptor| is an instance of the <a>permission
        descriptor type</a> of the `"wake-lock"` <a>powerful feature</a>.
      </p>
      <p>
        To <dfn>block a permission</dfn>, run these steps:
      </p>
      <ol class="algorithm">
        <li>Let |descriptor| be the <a>permission descriptor type</a> instance
        to be blocked.
        </li>
        <li>Set |descriptor|'s <a>permission state</a> to {{"denied"}}.
        </li>
        <li>Let |record| be the <a>platform wake lock</a>'s <a>state record</a>
        associated with |descriptor|'s <a data-lt=
        "WakeLockPermissionDescriptor.type">type</a> member.
        </li>
        <li>
          <a data-cite="infra#list-iterate">For each</a> |lock| in
          |record|.<a>[[\InstanceList]]</a>:
          <ol>
            <li>Run <a>release a wake lock</a> on |lock|.
            </li>
          </ol>
        </li>
      </ol>
      <p>
        To <dfn>obtain permission</dfn> for <a>wake lock type</a> |type|, run
        these steps <a>in parallel</a>. This async algorithm returns either
        {{"granted"}} or {{"denied"}}.
      </p>
      <ol class="algorithm">
        <li>Let |permissionDesc:PermissionDescriptor| be a newly created
        {{PermissionDescriptor}}.
        </li>
        <li>Set |permissionDesc|'s name to "`wake-lock`".
        </li>
        <li>Set |permissionDesc|'s type to |type|.
        </li>
        <li>Let |resultPromise| be the result of running <a>query a
        permission</a> with |permissionDesc|.
        </li>
        <li>Await |resultPromise| to settle.
        </li>
        <li>If |resultPromise| rejects, return {{"denied"}}.
        </li>
        <li>Otherwise, let |status:PermissionStatus| be the result of
        |resultPromise|.
        </li>
        <li>Let |state| be the value of |status|.<code><a data-cite=
        "permissions#dom-permissionstatus-state">state</a></code>.
        </li>
        <li>If |state| is {{"prompt"}}, run the following steps:
          <ol>
            <li>If these <a>obtain permission</a> steps were not <a>triggered
            by user activation</a>, return {{"denied"}}.
            </li>
            <li>Return the result of <a>requesting permission to use</a> with
            |permissionDesc|.
            </li>
          </ol>
        </li>
        <li>Otherwise, return |state|.
        </li>
      </ol>
      <div class="note">
        In the case the steps are run from a dedicated worker, then the
        <a>global object</a> is a {{DedicatedWorkerGlobalScope}}, which means
        that the <a>obtain permission</a> steps can never be <a>triggered by
        user activation</a>, meaning that in order to use wake locks from a
        dedicated worker, prior permission needs to granted from the
        <a>browsing context</a> who created it, e.g. the <a>browsing
        context</a> that is exists in the {{DedicatedWorkerGlobalScope}}'s
        <a>owner set</a>.
      </div>
    </section>
    <section data-dfn-for="WakeLockType">
      <h2>
        The <dfn>WakeLockType</dfn> enum
      </h2>
      <p>
        For the purpose of wake lock type description, this specification
        defines the following enumeration:
      </p>
      <pre class="idl">
        enum WakeLockType { "screen", "system" };
      </pre>
      <dl>
        <dt>
          <dfn>screen</dfn>
        </dt>
        <dd>
          <a>Screen wake lock</a> type.
        </dd>
        <dt>
          <dfn>system</dfn>
        </dt>
        <dd>
          <a>System wake lock</a> type.
        </dd>
      </dl>
    </section>
    <section>
      <h3>
        Concepts and state record
      </h3>
      <p>
        The term <dfn>platform wake lock</dfn> refers to platform interfaces
        with which the user agent interacts to query state and acquire and
        release a wake lock.
      </p>
      <p>
        A <a>platform wake lock</a> can be defined by the underlying platform
        (e.g. in a native wake lock framework) or by the user agent, if it has
        direct hardware control.
      </p>
      <p>
        Each <a>platform wake lock</a> (one per <a>wake lock type</a>) has an
        associated <dfn>state record</dfn> with the following <a data-cite=
        "ECMASCRIPT#sec-object-internal-methods-and-internal-slots">internal
        slots</a>:
      </p>
      <table class="simple">
        <thead>
          <tr>
            <th>
              Internal slot
            </th>
            <th>
              Initial value
            </th>
            <th>
              Description (<em>non-normative</em>)
            </th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <dfn>[[\InstanceList]]</dfn>
            </td>
            <td>
              The empty <a data-cite="infra#ordered-set">set</a>.
            </td>
            <td>
              A <a data-cite="INFRA#ordered-set">set</a> of {{WakeLock}}
              instances.
            </td>
          </tr>
          <tr>
            <td>
              <dfn>[[\RequestCounter]]</dfn>
            </td>
            <td>
              0.
            </td>
            <td>
              The value indicates the amount of current requests for the
              <a>wake lock type</a>. A number greater than zero indicates an
              <dfn>outstanding wake lock request</dfn>
            </td>
          </tr>
        </tbody>
      </table>
    </section>
    <section data-dfn-for="WakeLock">
      <h2>
        The <dfn>WakeLock</dfn> interface
      </h2>
      <p>
        The {{WakeLock}} interface allows the page to request wake locks of a
        particular type, to determine the current wake lock state and to
        receive notifications when the wake lock state is changed.
      </p>
      <pre class="idl">
        [Constructor(WakeLockType type), SecureContext, Exposed=(DedicatedWorker, Window)]
        interface WakeLock : EventTarget {
          [Exposed=Window] static Promise&lt;PermissionState&gt; requestPermission(WakeLockType type);
          readonly attribute WakeLockType type;
          readonly attribute boolean active;
          attribute EventHandler onactivechange;
          Promise&lt;void&gt; request();
          void abort();
          static sequence&lt;WakeLock&gt; query(optional WakeLockQueryFilter filter);
        };
      </pre>
      <section>
        <h3>
          Internal slots
        </h3>
        <table class="simple">
          <thead>
            <tr>
              <th>
                Internal slot
              </th>
              <th>
                Description (<em>non-normative</em>)
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                <dfn>[[\requestPromise]]</dfn>
              </td>
              <td>
                The pending <a>Promise</a> created during <a>request()</a>.
              </td>
            </tr>
          </tbody>
        </table>
      </section>
      <section>
        <h3>
          Constructor
        </h3>
        <p>
          To <dfn data-lt="create and initialize a wake lock object">create and
          initialize</dfn> a {{WakeLock}} object of type |type|, the following
          steps MUST be performed:
        </p>
        <ol class="algorithm">
          <li>Let |document| be the <a>responsible document</a> of the
          <a>current settings object</a>.
          </li>
          <li>If the <a>current global object</a> is the
          {{DedicatedWorkerGlobalScope}} object and its <a>owner set</a>
          <a data-xref-for="list">is empty</a>, throw a {{"NotAllowedError"}}
          {{DOMException}}.
          </li>
          <li>If the <a>current global object</a> is the {{Window}} object and
          the |document|'s <a>browsing context</a> is `null`, throw a
          {{"NotAllowedError"}} {{DOMException}}.
          </li>
          <li data-tests="wakelock-disabled-by-feature-policy.https.sub.html">
          If |document| is not <a>allowed to use</a> the <a>policy-controlled
          feature</a> named "`wake-lock`", throw a {{"NotAllowedError"}}
          {{DOMException}}.
          </li>
          <li>If the <a>user agent</a> <a data-lt="deny wake lock">denies the
          wake lock</a> of this |type| for |document|, throw a
          {{"NotAllowedError"}} {{DOMException}}.
          </li>
          <li data-tests="wakelock-api.https.html">Let |lock| be a new
          {{WakeLock}} object.
          </li>
          <li data-tests="wakelock-type.https.html">Set |lock|'s type to
          |type|.
          </li>
          <li>Let |record| be the <a>platform wake lock</a>'s <a>state
          record</a> associated with |type|.
          </li>
          <li>Add |lock| to |record|.<a>[[\InstanceList]]</a>.
          </li>
          <li data-tests="wakelock-onactivechange.https.html">If the wake lock
          of type |type| is currently <a>acquired</a>, set |lock|'s <a href=
          "#dom-wakelock-active">active</a> to `true`, otherwise to `false`.
          </li>
          <li>Return |lock|.
          </li>
        </ol>
      </section>
      <section data-link-for="WakeLock">
        <h3>
          <dfn>requestPermission()</dfn> static method
        </h3>
        <p>
          The <a>requestPermission()</a> method, when invoked, MUST run the
          following steps. This algorithm resolves with either {{"granted"}} or
          {{"denied"}}.
        </p>
        <ol class="algorithm">
          <li>Let |promise:Promise| be <a data-cite=
          "promises-guide#a-new-promise">a new promise</a>.
          </li>
          <li>Let |type| be the first argument.
          </li>
          <li>Return |promise| and run the following steps <a>in parallel</a>:
            <ol>
              <li>Let |state| be the result of running and waiting for the <a>
                obtain permission</a> steps with |type|.
              </li>
              <li>Resolve |promise| with |state|.
              </li>
            </ol>
          </li>
        </ol>
      </section>
      <section data-dfn-for="WakeLock" data-link-for="WakeLock">
        <h3>
          <dfn>type</dfn> attribute
        </h3>
        <p>
          When getting, the <a>type</a> attribute returns this {{WakeLock}}'s
          <a>wake lock type</a>.
        </p>
      </section>
      <section data-link-for="WakeLock">
        <h3>
          <dfn>active</dfn> attribute
        </h3>
        <p>
          The {{active}} attribute represents whether a wake lock is currently
          <a>acquired</a> by the {{WakeLock}} instance.
        </p>
      </section>
      <section data-dfn-for="WakeLock" data-link-for="WakeLock">
        <h3>
          <dfn>onactivechange</dfn> attribute
        </h3>
        <p data-tests="wakelock-onactivechange.https.html">
          A {{WakeLock}}'s <a>onactivechange</a> attribute is an
          {{EventHandler}} with the corresponding <a>event handler event
          type</a> of `activechange`. Fired when current wake lock status
          indicated by the <a>active</a> attribute changes.
        </p>
      </section>
      <section>
        <h3>
          <dfn>request()</dfn> method
        </h3>
        <p>
          To <dfn>abort the request steps</dfn> for a running instance of
          <a>request()</a>, run these additional steps:
        </p>
        <ol class="algorithm">
          <li>Set |lock|.<a>[[\requestPromise]]</a> to <code>undefined</code>.
          </li>
          <li>Abort the associated <a>request()</a> algorithm.
          </li>
        </ol>
        <p data-tests="wakelock-api.https.html" data-link-for="WakeLock">
          The <a>request()</a> method, when invoked, MUST run the following
          steps:
        </p>
        <ol class="algorithm">
          <li>Let |lock| be the <a>context object</a>.
          </li>
          <li>Let |record| be the <a>platform wake lock</a>'s <a>state
          record</a> associated with |lock|'s |type|.
          </li>
          <li>If the promise |lock|.<a>[[\requestPromise]]</a> is not
          <code>undefined</code>, return it.
          </li>
          <li>Let |promise:Promise| be <a data-cite=
          "promises-guide#a-new-promise">a new promise</a>.
          </li>
          <li>Set |lock|.<a>[[\requestPromise]]</a> to promise.
          </li>
          <li>Return |promise| and run the following steps <a>in parallel</a>:
            <ol>
              <li>Let |state| be the result of running and waiting for the <a>
                obtain permission</a> steps with |type|.
              </li>
              <li>If |state| is {{"denied"}}, then reject |promise| with a
              {{"NotAllowedError"}} {{DOMException}}, and abort these steps.
              </li>
              <li>Let |signal| be the |options| dictionary member of the same
              name if <a>present</a>, or `null` otherwise.
              </li>
              <li>If |signal|â€™s <a>aborted flag</a> is set, then reject
              |promise| with an "<a>AbortError</a>" {{DOMException}},
              and run <a>abort the request steps</a>.
              </li>
              <li>If |signal| is not `null`, then [=AbortSignal/add=] the
              following algorithm to |signal|:
                <ol>
                  <li>Decrease |record|.<a>[[\RequestCounter]]</a> by one.
                  </li>
                  <li>If |record|.<a>[[\RequestCounter]]</a> is 0, then run the
                  following steps <a>in parallel</a>:
                    <ol>
                      <li>Run <a>release a wake lock</a> on |lock|.
                      </li>
                    </ol>
                  </li>
                  <li>Reject |promise| with an {{ "AbortError" }}
                  {{DOMException}}, and run <a>abort the request steps</a>.
                  </li>
                </ol>
              </li>
              <li>If the <a>current global object</a> is not a
              {{DedicatedWorkerGlobalScope}} object, run the following steps:
                <ol>
                  <li>Let |document| be the <a>responsible document</a> of the
                  <a>current settings object</a>.
                  </li>
                  <li>If |document| is not <a>fully active</a>, reject
                  |promise| with a {{"NotAllowedError"}} {{DOMException}},
                  and run <a>abort the request steps</a>.
                  </li>
                  <li data-link-for="">If |lock|'s |type| is {{
                  WakeLockType["screen"] }} and the {{Document} of the
                  <a>top-level browsing context</a> is <a>hidden</a>, reject
                  |promise| with a {{"NotAllowedError"}} {{DOMException}},
                  and run <a>abort the request steps</a>.
                  </li>
                </ol>
              </li>
              <li>Increase |record|.<a>[[\RequestCounter]]</a> by one.
              </li>
              <li>If |record|.<a>[[\RequestCounter]]</a> is 1, run the
              following steps:
                <ol>
                  <li>Let |success| be the the result of running and waiting
                  for <a>acquire a wake lock</a> on |lock|.
                  </li>
                  <li>If |success| is `false` then reject |promise| with a
                  {{"NotAllowedError"}} {{DOMException}}, and run
                  <a>abort the request steps</a>.
                  </li>
                </ol>
              </li>
              <li>Resolve |promise| with `void`.
              </li>
            </ol>
          </li>
        </ol>
      </section>
      <div class="note">
        The additional visibility requirement for screen wake lock is to
        prevent keeping the screen on when the page is not visible, such as
        when the browser is minimized. As this condition is transient and not
        under control of the web page, the specification chooses to
        automatically acquire and release the lock when visibility changes
        rather than having the page to deal with it, e.g by re-requesting the
        lock each time the page becomes visible again.
      </div>
      <section>
        <h3>
          <dfn>abort()</dfn> method
        </h3>
        <p>
          The <a>abort()</a> method, when invoked, MUST run the following
          steps:
        </p>
        <ol class="algorithm">
          <li>Let |lock| be the <a>context object</a>.
          </li>
          <li>Let |record| be the <a>platform wake lock</a>'s <a>state
          record</a> associated with |lock|'s |type|.
          </li>
          <li>Decrease |record|.<a>[[\RequestCounter]]</a> by one.
          </li>
          <li>If |record|.<a>[[\RequestCounter]]</a> is 0, then run the
          following steps <a>in parallel</a>:
            <ol>
              <li>Run <a>release a wake lock</a> on |lock|.
              </li>
            </ol>
          </li>
        </ol>
      </section>
      <section data-link-for="WakeLockQueryFilter" data-dfn-for=
      "WakeLockQueryFilter">
        <h3>
          The <dfn>WakeLockQueryFilter</dfn> dictionary
        </h3>
        <pre class="idl">
          dictionary WakeLockQueryFilter {
            WakeLockType? type;
            boolean? active;
          };
        </pre>
        <p>
          The <dfn>type</dfn> member and <dfn>active</dfn> member allows
          filtering by <a>wake lock type</a> and activity (whether the wake
          lock is currently <a>acquired</a> by the <a>user agent</a>.).
        </p>
      </section>
      <section data-link-for="WakeLock">
        <h3>
          <dfn>query()</dfn> static method
        </h3>
        <p>
          The <a>query()</a> method, when invoked, MUST run the following
          steps.
        </p>
        <ol class="algorithm">
          <li>Let |filter| be the first argument.
          </li>
          <li>Let |records| be the empty <a>list</a>.
          </li>
          <li>Let |type| be the |filter| dictionary member of the same name.
          </li>
          <li>Let |active| be the |filter| dictionary member of the same name.
          </li>
          <li>If |type| is <a>present</a>, add the <a>platform wake lock</a>'s
          <a>state record</a> associated with <a>wake lock type</a> |type| to
          |records|.
          </li>
          <li>Otherwise, add all <a>state records</a> to |records|.
          </li>
          <li>Let |locks| be the empty <a data-cite=
          "infra#ordered-set">set</a>.
          </li>
          <li>[=list/For each=] |record| in |records|:
            <ol>
              <li>[=list/For each=] |lock| in
              |record|.<a>[[\InstanceList]]</a>:
                <ol>
                  <li>If |active| is <a>present</a>, add |lock| to |locks| if
                  |active| is equal to |lock|'s active attribute value.
                  </li>
                  <li>Otherwise, add |lock| to |locks|
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return |locks|.
          </li>
        </ol>
      </section>
    </section>
    <section>
      <h2>
        Managing Wake Locks
      </h2>
      <p data-tests=
      "wakelockrequest-is-independent.https.html, wakelock-promise.https.html">
        This section applies to each <a>wake lock type</a> equally and
        independently, unless a particular <a>wake lock type</a> is explicitly
        mentioned.
      </p>
      <p>
        The <a>user agent</a> <dfn data-lt=
        "acquire wake lock|acquire the wake lock|acquired">acquires the wake
        lock</dfn> by requesting the underlying operating system to apply the
        lock. The lock is considered acquired only when the request to the
        operating system succeeds.
      </p>
      <p>
        Conversely, the <a>user agent</a> <dfn data-lt=
        "release wake lock">releases the wake lock</dfn> by requesting the
        underlying operating system to no longer apply the wake lock. The lock
        is considered released only when the request to the operating system
        succeeds.
      </p>
      <p>
        The wake lock is <dfn data-lt=
        "applicable wake lock|applicability">applicable</dfn> if the state of
        the operating system permits application of the lock (e.g. there is
        sufficient battery charge).
      </p>
      <p data-tests="wakelock-applicability-manual.https.html">
        The <a>screen wake lock</a> MUST NOT be <a>applicable</a> after the
        screen is manually switched off by the user until it is switched on
        again. Manually switching off the screen MUST NOT affect the
        <a>applicability</a> of the <a>system wake lock</a>.
      </p>
      <div class="note">
        Whether the wake lock is applicable is a transient condition, e.g. when
        the battery charge is low but then the battery is recharged. So like
        the visibility requirement, this is part of automatic wake lock
        management and not part of the decision process whether to allow or
        deny the wake lock.
      </div>
      <section>
        <h3>
          Auto-releasing wake locks
        </h3>
        <p>
          A user agent may <a>release a wake lock</a> at any time it:
        </p>
        <ul>
          <li>Detects abnormal operation: such as infinite loops and tasks
          exceeding imposed time limits (if any).
          </li>
          <li>Battery is considered low and discharging.
          </li>
          <li>The user turns on some kind of device power conservation mode.
          </li>
        </ul>
      </section>
      <section>
        <h3>
          Handling document loss of full activity
        </h3>
        <p>
          When the user agent determines that a <a>responsible document</a> of
          the <a>current settings object</a> is no longer <a>fully active</a>,
          it must run these steps:
        </p>
        <ol class="algorithm">
          <li data-link-for="WakeLockType">Let |record| be the <a>platform wake
          lock</a>'s <a>state record</a> associated with <a>wake lock type</a>
          {{"screen"}} and {{"system"}}.
          </li>
          <li>
            <a data-cite="infra#list-iterate">For each</a> |lock| in
            |record|.<a>[[\InstanceList]]</a>:
            <ol>
              <li>Run <a>release a wake lock</a> on |lock|.
              </li>
            </ol>
          </li>
        </ol>
        <div class="note">
          Only documents presented to the user, thus with an associated
          <a>browsing context</a> can be <a>active documents</a>, so the above
          steps are only relevant for these.
        </div>
      </section>
      <section>
        <h3>
          Handling document loss of visibility
        </h3>
        <p>
          When the user agent determines that the <a>visibility state</a> of
          the {{Document}} of the <a>top-level browsing context</a> changes, it
          must run these steps:
        </p>
        <ol class="algorithm">
          <li>Let |document| be the {{Document}} of the <a>top-level browsing
          context</a>.
          </li>
          <li>If |document|'s <a>visibility state</a> is `"visible"`, abort
          these steps.
          </li>
          <li>Let |screenRecord| be the <a>platform wake lock</a>'s <a>state
          record</a> associated with <a>wake lock type</a> {{
          WakeLockType["screen"] }}.
          </li>
          <li>
            <a data-cite="infra#list-iterate">For each</a> |lock| in
            |screenRecord|.<a>[[\InstanceList]]</a>:
            <ol>
              <li>Run <a>release a wake lock</a> on |lock|.
              </li>
            </ol>
          </li>
        </ol>
        <div class="note">
          As some locks like {{ WakeLockType["system"] }} are allowed to run
          while the {{Document}} of the <a>top-level browsing context</a> is
          not visible, it is encouraged that user agents show some UI
          indicating this.
        </div>
        <div class="note">
          The <a>visibility state</a> is only exposed on the {{Window}} object,
          thus the above steps are not relevant to wake locks running as part
          of a dedicated worker.
        </div>
      </section>
      <section>
        <h3>
          Acquire wake lock algorithm
        </h3>To <dfn>acquire a wake lock</dfn> for a given {{WakeLock}} object
        |lock|, run these steps <a>in parallel</a>:
        <ol class="algorithm" data-link-for="WakeLock">
          <li>Let |type| be |lock|'s <a>type</a>.
          </li>
          <li>If the wake lock for type |type| is not <a>applicable</a>, return
          `false`.
          </li>
          <li>Ask the underlying operation system to <a>acquire the wake
          lock</a> of type |type| and let |success| be `true` if the operation
          succeeded, or else `false`.
          </li>
          <li data-tests="wakelock-onactivechange.https.html">If |success| is
          different from |lock|'s <a>active</a>, set |lock|'s <a>active</a> to
          |success| and <a>fire an event</a> named `"activechange"` at |lock|.
          </li>
          <li>Return |success|.
          </li>
        </ol>
      </section>
      <section>
        <h3>
          Release wake lock algorithm
        </h3>
        <p>
          To <dfn>release a wake lock</dfn> for a given {{WakeLock}} object
          |lock|, run these steps <a>in parallel</a>:
        </p>
        <ol class="algorithm" data-link-for="WakeLock">
          <li>Let |type| be |lock|'s <a>type</a>.
          </li>
          <li>If the promise
            |lock|.<a>[[\requestPromise]]</a> not <code>undefined</code> and is
            pending, reject it with an "<a>AbortError</a>" <a>DOMException</a>
            and <a>abort the request steps</a> for the associated running
            <a>request()</a> algorithm.
          </li>
          <li>Ask the underlying operation system to release the wake lock of
          type |type| and let |success| be `true` if the operation succeeded,
          or else `false`.
          </li>
          <li data-tests="wakelock-onactivechange.https.html">If |success| is
          different from |lock|'s <a>active</a>, set |lock|'s <a>active</a> to
          the negated |success| and <a>fire an event</a> named `"activechange"`
          at |lock|.
          </li>
          <li>If |lock|'s type is `"screen"` run the following:
            <ol>
              <li>The <a>user agent</a> MUST reset the platform-specific
              inactivity timer after which the screen is actually turned off.
              </li>
            </ol>
          </li>
          <li>Return |success|.
          </li>
        </ol>
        <div class="note">
          Resetting the inactivity timer prevents the screen from going blank
          immediately after the wake lock is released.
        </div>
      </section>
    </section>
    <section>
      <h2>
        Security and privacy considerations
      </h2>
      <p>
        Application of a wake lock causes various device components such as
        display or CPU to operate at higher power levels than they otherwise
        would. This can lead to undesirable and potentially dangerous effects
        such as excessive heating and faster than normal battery charge
        depletion. The latter is particularly relevant to mobile devices which
        may not have a stationary power source readily available. Complete
        battery depletion at an unexpected time can lead to inability of the
        user to make or receive calls and use network services, including the
        emergency call service. Implementations should consider preventing wake
        lock application if they determine that the remaining battery capacity
        is low.
      </p>
      <p data-tests="wakelock-state-is-global.https.html">
        The ability to observe the global state of a wake lock can create a
        communication channel between two otherwise isolated {{Document}}
        objects. One document can request wake lock which changes the global
        wake lock state, and another document can observe this change by
        subscribing to events in {{WakeLock}}.
      </p>
      <p>
        When the <a>user agent</a> does not <a>acquire wake lock</a> even
        though a browsing context has requested it, this can be observed by the
        browsing context and can possibly disclose sensitive information about
        the state of the device such as that battery level is low.
      </p>
    </section>
    <section id="examples" class="informative">
      <h2>
        Examples
      </h2>
      <pre class="example js" title="Acquire and releases a screen wake lock">
        async function tryKeepScreenAlive(minutes) {
          const lock = new WakeLock("screen");
          lock.request();

          setTimeout(() =&gt; lock.abort(), minutes * 60 * 1000);
        }

        tryKeepScreenAlive(10);
      </pre>
      <p>
        This example allows the user to request a screen wake lock by clicking
        on a checkbox, but updates the checkbox checked state in case the wake
        lock state changes:
      </p>
      <pre class="example js">
        const checkbox = document.createElement("input");
        checkbox.setAttribute("type", "checkbox");
        document.body.appendChild(checkbox);

        // We abort the wake lock after 5 seconds
        const controller = new AbortController();
        const signal = controller.signal;
        setTimeout(() =&gt; controller.abort(), 5000);

        const lock = new WakeLock("screen");

        lock.onactivechange = () =&gt; checkbox.checked = lock.active;

        try {
          checkbox.disabled = true;
          if (checkbox.checked) {
            await lock.request();
          } else {
            lock.abort();
          }
        } catch {
          // On failure, reset the checkbox to reflect the
          // current state. `onactivechanged` will not have fired.
          checkbox.checked = lock.active;
        } finally {
          checkbox.disabled = false;
        }
      </pre>
      <p>
        In this example, two screen wake lock requests are created and released
        independently:
      </p>
      <pre class="example js">
        const lock1 = new WakeLock("screen");
        const lock2 = new WakeLock("screen");

        lock1.request();

        // ...somewhere else

        lock2.request();

        // ...somewhere else

        lock2.abort();
        lock1.abort();
      </pre>
    </section>
    <section>
      <h2>
        Dependencies
      </h2>
      <p>
        <dfn data-cite="HTML/webappapis.html#global-object">global object</dfn>
        and <dfn data-cite="HTML/browsers.html#browsing-context">browsing
        context</dfn> are defined in [[HTML]].
      </p>
      <p>
        <code><dfn data-cite="WEBIDL#aborterror">AbortError</dfn></code>,
        <code><dfn data-cite=
        "WEBIDL#notsupportederror">NotSupportedError</dfn></code>, and
        <code><dfn data-cite=
        "WEBIDL#notallowederror">NotAllowedError</dfn></code> are defined in
        [[WEBIDL]].
      </p>
      <p>
        Document's <code><dfn data-cite=
        "PAGE-VISIBILITY#dom-document-hidden">hidden</dfn></code> attribute,
        and <dfn data-cite="PAGE-VISIBILITY#dfn-visibility-states">visibility
        state</dfn> are defined in [[PAGE-VISIBILITY]].
      </p>
    </section>
    <section id="conformance">
      <p>
        This specification defines conformance criteria for a single product: a
        <dfn>user agent</dfn> that implements the interfaces that it contains.
      </p>
      <p>
        The <a>user agent</a> MUST implement the APIs defined in this
        specification in a manner that conforms to the <a href=
        "https://heycam.github.io/webidl/#ecmascript-binding">ECMAScript
        Bindings</a> defined in [[WEBIDL]].
      </p>
    </section>
    <section id="idl-index" class="appendix"></section>
    <section class="appendix informative" id="acknowledgments">
      <h2>
        Acknowledgments
      </h2>
      <p>
        We would like to offer our sincere thanks to Mounir Lamouri, Sergey
        Konstantinov, Matvey Larionov, Dominique Hazael-Massieux, Domenic
        Denicola, Thomas Steiner for their contributions to this work.
      </p>
    </section>
  </body>
</html>
